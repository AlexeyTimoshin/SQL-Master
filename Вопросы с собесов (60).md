### 1. Что такое реляционная база данных? Какие бывают? Почему так называются?  

* Иерархическая БД – это БД, в которых организована древовидная структура (файловая система ПК).  
* Сетевые БД – это БД связи, которые представлены графами и узлами (система бронирования авиабилетов).   
* Объектно-ориентированные БД – это БД, в которых данные представлены в виде объектов с  
  атрибутами и методами (система управления контентом).  
* Реляционные БД – это БД, данные в которых организованны в таблицы со строками и столбцами.   
* NoSQL БД – это БД которые не используют табличную модель хранения, а используют, например,  
  json или xml форматы.
    
### 2. Плюсы и минусы реляционных баз данных
    
* **Плюсы**  
    Используют таблицы столбцов и строк, поэтому они отображают данные проще,  
    чем другие типы и работать с ними удобнее.  
    Такая табличная структура создана специально для обработки данных, что повышает  
    производительность и позволяет использовать сложные, высокоуровневые запросы.  
    Легко масштабировать данные, добавляя строки, столбцы или целые таблицы, не  
    нарушая при этом общей структуры базы.  
    
* **Минусы**
    Реляционные БД могут масштабироваться только до определенного предела. Если  
    говорить о размере базы, то в некоторых БД есть строгое ограничение по длине столбцов.  
    Если вы создаете базу на отдельном сервере, то при ее разрастании придется покупать  
    дополнительное место, то есть в долгосрочной перспективе ее поддержание обходится  
    не дешево.  
    Кроме того, постоянное добавление новых элементов может усложнить базу и затруднить  
    установление связей между новыми частями. Сложные отношения между данными замедляют  
    запросы и негативно сказываются на производительности.  
    
### 3. Каковы основные типы команд SQL?  

  Команды SQL можно разделить на четыре типа:   
  * язык запросов к данным **DQL**  
  * язык определения данных **DDL**  
  * язык манипулирования данными **DML**  
  * язык управления данными **DCL**  
    
### 4. Объясните разницу между SQL и MySQL/POSTGRESQL/MS SQL
    
  **SQL** это общее название диалекта запросов к базам данных.  
  **MySQL/POSTGRESQL/MS SQL** - СУБД (ситема управления базами данных)  
    
### 5. Что такое первичный ключ(PrKey)?
    
  Это поле (поля), которые однозначно идентифицируют определенную строку в таблице.  
  ПК должен быть уникальный и NOT NULL.
    
### 6. Что такое внешний ключ?
    
  Поле (поля) в одной таблице, которое ссылается на поле (группу полей) в другой таблице.  
  Он устанавливает связь между двумя таблицами (часто используется PrKey).  
    
  Внешний ключ обеспечивает ссылочную целостность данных.  
  Значения столбца (или группы столбцов) должны соответствовать значениям   
  в некоторой строке другой таблицы.  
    
  Внешний ключ предотвращает несогласованность данных и обеспечивает их точность  
    
### 7. Чем PrKey отличается от индекса и от внешнего ключа?
    
  **PrKey** и есть индекс — B-tree (накладывает ограничение **UNIQUE NOT NULL**)  
      
  **PrKey** накладывает ограничение уникальности для индетификации данных  
  внутри таблицы, внешний ключ служит для обеспечения целостности с внешней таблицей.  
    
  Первичный ключ — это столбец или комбинация столбцов, которые уникально идентифицируют 
  каждую строку в таблице. Он обеспечивает целостность и уникальность данных в пределах таблицы. 
  У каждой таблицы может быть только один первичный ключ.
    
  Внешний ключ — это столбец или комбинация столбцов, которые ссылаются на столбец 
  (первичный ключ) другой таблицы. Он устанавливает связь между двумя таблицами и обеспечивает
  ссылочную целостность. Таблица может иметь несколько внешних ключей, указывающих на её связь  
  с разными таблицами.  
    
### 8. Отличие первичного ключа от UNIQUE CONSTRAINT?
    
  PrKey не может быть **NULL**
    
### 9. Что такое CONSTRAINT?
  
  Ключевое слово **CONSTRAINT** используется для задания имени ограничений.  
  В качестве ограничений могут использоваться **PRIMARY KEY, UNIQUE, CHECK**
    
### 10. Разница между WHERE и HAVING
    
  **WHERE** используется для фильтрации данных перед их группировкой.  
  Применяется в операторах **SELECT**, **UPDATE** и **DELETE**.  
    
  **HAVING** используется для фильтрации данных после их группировки.  
  Применяется только с оператором **SELECT**.
    
### 11. В чём разница между операторами DELETE и TRUNCATE?
    
  **DELETE** используется для удаления определённых записей из таблицы.  
  **DELETE** методично удаляет всё указанное по одной записи  
      
  **TRUNCATE** удаляет саму таблицу, после чего создаёт её заново, но без записей. 
  Предварительно проверяется, что это не поломает внешние ссылки,иначе в выполнении  
  будет отказано.  
    
### 12. В чём разница между операторами GROUP BY и HAVING?
    
 * **GROUP BY**  используется для группировки строк на основе определённого  
  столбца (столбцов).      
 * **HAVING** используется для фильтрации результатов после группировки.  
       
### 13. Какие бывают JOIN, зачем нужны, как работают?
    
    ![[othr_join.png]]
    
### 14. Внутреннее устройство JOIN
  1. Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы  
      т.е. происходит [декартово произведение](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5) двух множеств,
     результатом которого является новое множество, состоящее из всевозможных пар исходных строк.  
  3. Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения,
     указанное после оператора **ON**.
  5. После этого в соответствии с выбранным типом объединения формируется результирующая таблица.  
 
### 15. Что будет с LEFT JOIN если в правой таблице нет значений?
    
Вместо них будет **NULL**
    
### 16. Максимум и минимум строк при разных JOIN
  [Подробнее тут](https://github.com/AlexeyTimoshin/SQL-Master/blob/main/Its%20all%20about%20JOIN-s.md)
  
  |**t1-N, t2 - M**|**MIN**|**MAX**|
  |---|---|---|
  |**INNER JOIN**|0|N*M|
  |**LEFT JOIN**|N|N * M|
  |**RIGHT JOIN**|M|N * M|
  |**FULL JOIN**|MAX(M, N)|N * M|
  |**CROSS JOIN**|N * M|N * M|
   
### 17. Чем отличается UNION от JOIN?
    
  Короткий ответ:  
      
  **UNION** - операция вертикального объединения  
      
  **JOIN** - операция соединения таблиц/запросов
    
  Подробный ответ:
    
  `UNION` объединяет наборы результатов вертикально, располагая их друг над другом.   
      
  `JOIN` объединяет строки по горизонтали, сопоставляя их на основе заданного условия.
    
  `UNION` работает с наборами результатов таблиц или запросов.   
      
  `JOIN` работает с таблицами в базе данных
    
  `UNION` требует, чтобы количество столбцов в каждом операторе `SELECT` было одинаковым.  
      
  `UNION` по умолчанию удаляет дубликаты записей (для включения дубликатов следует использовать `UNION ALL`).  
   
  `JOIN` не обрабатывает дубликаты    
    
### 18. В чём разница UNION и UNION ALL?
      
  `UNION` по умолчанию удаляет дубликаты записей  
      
  `UNION ALL` добавит все строки.  
      
### 19. Требования к таблицам при UNION
        
  Одинаковое число столбцов  
  Типы столбцов должны быть совместимыми  
      
### 20. Меняет ли ORDER BY количество строк в запросе?
    
  Нет. ORDER BY это оператор сортировки - по возрастанию или убыванию
    
### 21. EXPLAIN и EXPLAIN ANALYZE
    
  **EXPLAIN** выводит информацию, необходимую для понимания, что  
  делает ядро при каждом конкретном запросе.  
    
### 22. Есть запрос. Полгода работал хорошо, а потом начал в 10-100 раз дольше.  В запросе соединяются 2 таблицы. На что нам в 1 очередь посмотреть?  
    
### 23. Для какого запроса можно вынести условие WHERE в ON и это не повлияет на результат запроса?
    
  Для **INNER JOIN** 
  2 Следующих запроса равны
    
  ```SQL
    SELECT * FROM t1 
    JOIN t2 ON t1.id = t2.id
    WHERE t1.amonunt > 100 
    
    SELECT * FROM t1 
    JOIN t2 ON t1.id = t2.id
    AND t1.amonunt > 100 
  ```    
    
### 24. Что такое CTE?
    
  CTE - это Common Table Expression, общие табличные выражения, их еще называют конструкциями с WITH.  
  Фактически это создание временных таблиц, но существующих только для одного запроса,а не для сессии.  
  К ним можно обращаться внутри этого запроса. Такой запрос хорошо читается, он понятен, его легко  
  видоизменять, если потребуется.  
    
### 25. LEFT JOIN a,b если поменять местами таблицы (таблицы разные), получим ли другой результат?
  Да
    
### 26. Что выведет SELECT 5 + NULL?
  NULL
    
### 27. Что делает функция COALESCE?
    
  Функция **COALESCE** возвращает первое ненулевое выражение из списка. Если все выражения определены  
  как NULL, то функция **COALESCE** вернет NULL. Если можно вернуть не NULL - возвращается первое  
  непустое значение.  
    
 ### 28. Что выведет COALESCE(NULL, NULL)?
  
  **NULL**
    
### 29. Базовые принципы оптимизации запросов

 1. Сначала фильтруй, потом группируй
 2. Сначала фильтруй, потом джоини
 3. equi join. Нет преобразованиям на джоинах. (то есть на равенство). Оптимизатор иначе будет выбирать
    только nested loop, хотя есть более быстрые джоины, но работают только на равенство
 4. in только для маленьких множеств
 5. никогда не используем union
 6. подзапросы - точки особого внимания (cte, но это не точно)
 7. не нужно пихать оконные функции куда попало. lead/lag/ntile - оправданы
 8. нужно понимать индексы и партиции
 9. order by - дорогая операция, но для принудительного merge join - ок (это такой хинт)
 10. всегда читаем документацию! постгрес всегда материализует cte -> строит статистику на таблицу
 11. избегайте USING синтаксис
 12. никакой преждевременной оптимизации! (смотрим план запроса на проде и только тогда оптимизируем, если реально нужно)
     
### 30. Перечислите физические виды джоинов
    
  **Nested Loops Join** SQL берет первое значение из первой таблицы 
  (наша "внешняя" таблица выбирается сервером по умолчанию) и сравнивает его 
  с каждым значением во второй "внутренней" таблице в поисках совпадения.
    
  **Hash Join** для объединения двух объектов строится hash по ключу объединения
  на одном из объектов и в процессе объединения по полю объединения вычисляется 
  hash второго объекта и происходит сопоставление элементов объектов по hash 
  ключам объединения. Можно создать только отношение равенства.
    
  **Merge Join** соединения слиянием теоретически являются самыми быстрыми и доступными
  операторами физического соединения, однако они требуют, чтобы данные из обоих 
  входных данных были отсортированы.
    
### 31. Как найти дубликаты в таблице?

  Есть несколько вариантов:
  1. Через having
  2. Union
  3. Оконная функция row_number
  4. через джоин таблицы на саму себя (если есть поле id, которое уникальное)  

### 32. Как смоделировать EXCEPT через JOIN в SQL?

  1. Соединить 2 таблицы через LEFT JOIN
  2. Оставить только те записи, для которых в правой таблице все значения - NULL
     
### 33. Перечислите действия над множествами
 - `UNION` - объединение строк (дополнение результатов первого запроса результатами второго запроса);  
 - `INTERSECT` - пересечение строк (остаются строки, присутствующие в результатах обоих запросов);  
 - `EXCEPT` - исключение строк (из строк первого запроса исключаются строки второго запроса).  
   
### 34. Что такое нормализация?
    
  Нормализация базы данных — это стратегия эффективной организации данных.  
  Цель состоит в том, чтобы уменьшить количество избыточных данных,  
  чтобы одни и те же данные не хранились в нескольких таблицах.  
  +:  
  - помогает поддерживать согласованность и точность данных.  
  - облегчает процессы запроса и анализа данных  
    
### 35. Объясните концепцию нормализации баз данных
    
  Нормализация — это процесс организации данных в базе с целью  
  устранения избыточности и необоснованных зависимостей.  
    
### 36. Почему использовать NOT IN плохая практика?
    
  `NOT IN` - опасная штука. Нужно гарантировать, что в результате подзапроса  
  не встретится значение `NULL`.  Допустим есть таблица с магазинами.  
  Мы делаем запрос с условием WHERE store_id NOT IN (100, 300, 500, NULL).  
    
  Запрос не вернет ничего.  
  Почему так?  `store_id NOT IN (100, 300, 500, NULL)` принимает значение `TRUE`,  
  когда `store_id` не равно ни одному из значений в скобках.  
  Выражение `store_id != NULL` принимает значение `NULL`, что означает - неизвестно.  
  Так как неизвестно равно ли `store_id` одному из з начений, то строка отбрасывается.  
  Лучше использовать  `NOT EXISTS`, не нужно исключать `NULL` значения, как  
  это требуется в `NOT IN`.
    
### 37. Перечислите оконные функции
    
  1. Агрегирующие функции `SUM`, `AVG`, `MAX`, `MIN`, `COUNT`  
  2. Ранжирующие функции `DENSE_RANK`, `ROW_NUMBER`, `RANK`  
    
  - `ROW_NUMBER` — простая нумерация (1, 2, 3, 4, 5).  
  - `RANK` — нумерация с учётом повторяющихся значений с пропуском рангов (1, 2, 2, 4, 5).  
  - `DENSE_RANK` — нумерация с учётом повторяющихся значений без пропуска рангов (1, 2, 2, 3, 4).  
    
  3. Функции смещения `LEAD`, `LAG`, `FIRST_VALUE`, `LAST_VALUE`  
   Также важно знать, что оконные функции разрешается использовать в запросе только в   
  `SELECT` и `ORDER BY`. Во всех остальных операторах, включая `WHERE`, `HAVING` и `GROUP BY`,
   они запрещены, так как логически выполняются после обычных агрегирующих функций.  

### 39. В чем разница между типом данных CHAR и VARCHAR в SQL?
    
  **VARCHAR** - переменная длина 
  **CHAR** - фиксированная
    
### 40. Равны ли NULL?
    
  Нет
    
### 41. Может ли значение в столбце, на который наложено ограничение FOREIGN KEY равняться NULL?
    
  Может, если на данный столбец не наложено ограничение **NOT NULL**
    
### 42. Расскажите порядок выполнения запроса
    
  **FROM** -- указание источника данных  
  **WHERE** -- фильтрация данных  
  **GROUP BY** -- группировка данных  
  **HAVING** -- фильтрация данных после группировки  
  **SELECT** -- перечисление полей результирующей таблицы  
  **ORDER BY** -- сортировка результирующей таблицы  
  **LIMIT** -- ограничение количества выводимых записей  
    
### 43. Что такое VACUUM в PostgreSQL?
    
  **VACUUM** высвобождает пространство, занимаемое «мёртвыми» кортежами.   
  При обычных операциях Postgres кортежи, удалённые или устаревшие в результате  
  обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не  
  будет выполнена команда VACUUM. Таким образом, периодически необходимо  
  выполнять VACUUM. Особенно для часто изменяемых таблиц.  
    
### 44. Что такое денормализация баз данных?
    
  Денормализация базы данных — это процесс осознанного приведения базы данных к  
  виду, в котором она не будет соответствовать правилам  нормализации.  
  Обычно это необходимо для повышения производительности и скорости извлечения данных,  
  за счет увеличения избыточности данных.  
    
  Хотя денормализация может быть полезным инструментом повышения производительности,  
  важно использовать её надлежащим образом и следовать некоторым лучшим практикам,  
  чтобы база данных оставалась последовательной и удобной для обслуживания:  
    
  1. **Определите “горячие точки”.**  Перед денормализацией базы данных важно определить  
  “горячие точки”, где производительность является критической. Это поможет определить,  
  какие таблицы необходимо денормализовать, а какие следует оставить нормализованными.  

  2. **Используйте денормализацию с умом**. Слишком большое количество избыточных данных  
  может привести к несоответствиям и затруднить обслуживание базы данных с течением времени.  

  3. **Сохраняйте данные последовательными.**  При дублировании данных в таблицах важно  
  сохранять их последовательность, чтобы избежать несоответствий. Этого можно добиться с  
  помощью триггеров или хранимых процедур, обновляющих данные во всех связанных таблицах  
  при внесении изменений.

  4. **Используйте индексы.** Денормализация может привести к созданию больших таблиц с  
  большим количеством данных. Чтобы обеспечить высокую производительность запросов, важно  
  использовать индексы для оптимизации запросов и сокращения времени, затраченного на  
  их выполнение.  
    
### 45. Какие бывают типы подзапросов?

  1. Коррелированный подзапрос: это запрос, который выбирает данные из таблицы со  
  ссылкой на внешний запрос. Он не считается независимым запросом, поскольку ссылается  
  на другую таблицу или столбец в таблице.  

  3. Некоррелированный подзапрос: этот запрос является независимым запросом, в котором  
  выходные данные подзапроса подставляются в основной запрос.  
    
### 46. Какой порядок выполнения логических операторов в WHERE (OR, AND, NOT)?
  
  1. NOT
  2. AND
  3. OR
     
### 47. Что такое представление в SQL?

  Представление — это виртуальная таблица, в которой отображается  результат запроса   
  `SELECT`. Оно не хранит данные, а позволяет представить данные из одной или нескольких  
  таблиц в определённом формате.  
    
### 48. Объясните разницу между представлением и таблицей
    
  Таблица — это основная структура в базе данных, которая хранит данные в строках и столбцах.   
  Она используется для организации и хранения данных в табличном формате.  
  Представление — это виртуальная таблица, полученная из одной или нескольких таблиц.  
  Она не хранит данные, но определяется запросом. Представления позволяют упростить сложные  
  запросы, скрыть конфиденциальную информацию и представить подмножество данных пользователям,  
  не давая им прямого доступа к основным таблицам.  
    
### 49. Объясните концепцию свойств ACID в транзакциях базы данных

  - **Атомарность**. Транзакция рассматривается как единое целое и либо выполняется  
   полностью, либо не завершается вообще. Если какая-либо часть транзакции выполняется  
  неудачно, вся транзакция отменяется, оставляя базу данных в исходном состоянии.  

  - **Согласованность**. Транзакция переводит базу данных из одного согласованного  
    состояния в другое. Это гарантирует, что ограничения целостности данных не будут  
    нарушены после завершения транзакции.  
    
  - **Изоляция**. Транзакции выполняются отдельно друг от друга. Изменения, внесённые  
    одной транзакцией, не видны другим транзакциям до тех пор, пока они не будут зафиксированы.  
    
  - **Устойчивость**. Как только транзакция зафиксирована, её изменения становятся  
    постоянными и сохраняются после любых дальнейших сбоев, таких как сбои питания или системы.  
    
### 50. В чем разница между коррелированным и некоррелированным подзапросом?
    
  Основное различие между коррелированными и некоррелированными подзапросами в SQL  
  заключается в том, как они ссылаются на внешний запрос.  
  Некоррелированный подзапрос может выполняться независимо от внешнего запроса, в то  
  время как коррелированный ссылается на один или несколько столбцов из внешнего запроса,  
  используя значения из него.  
    
### 51. В чем разница между транзакцией и batch?
    
  В SQL транзакция – это единая логическая единица работы, включающая один или несколько   
  операторов SQL. Транзакция выполняется атомарно. Это значит, что все операторы внутри  
  транзакции должны быть либо зафиксированы, либо отменены как единое целое.  
    
  Транзакции обеспечивают согласованность и целостность данных в базе, позволяя группировать  
  несколько операций и выполнять их как единое целое. Если какое-либо из утверждений в  
  транзакции завершается неудачей, вся транзакция отменяется, и база данных возвращается  
  в прежнее состояние.  
    
  С другой стороны, batch (пакет) – это набор операторов SQL, которые передаются в базу  
  данных для выполнения в виде группы. В отличие от транзакций, пакеты не обеспечивают  
  такого же уровня атомарности или гарантии согласованности. Каждый оператор в пакете  
  выполняется отдельно, и любые ошибки или исключения обрабатываются независимо. Пакеты  
  обычно используются для таких задач, как загрузка данных в базу данных, запуск отчетов  
  или выполнение рутинных задач обслуживания.  
    
### 52. Что такое оптимизатор SQL-запросов и как он работает?
    
  Оптимизатор SQL-запросов — это программный компонент СУБД, который автоматически  
  генерирует наиболее эффективный план выполнения для заданного запроса. Он анализирует  
  запрос, учитывает доступные индексы, статистику по таблицам и другую информацию,  
  чтобы сгенерировать план выполнения, минимизирующий затраты на доступ к данным и  
  их обработку.
    
### 53. Что такое хранимая процедура и каковы её преимущества?
    
  Хранимая процедура — это предварительно скомпилированный набор операторов SQL,  
  который хранится вбазе данных и может быть выполнен одной командой  
    
  Преимущества
   
  1. **Повышенная производительность.** Хранимые процедуры компилируются и оптимизируются движком базы данных,
       что может привести к более быстрому выполнению операции, чем специальные SQL-запросы.
  2. **Возможность повторного использования**. Хранимые процедуры можно вызывать из нескольких приложений и
       использовать для выполнения сложных операций с базой данных, что сокращает объем кода, который необходимо писать и поддерживать.
  3. **Безопасность**. Хранимые процедуры можно использовать для контроля доступа к конфиденциальным операциям
       базы данных, ограничивая доступ определенным пользователям или ролям. Это помогает предотвратить
       несанкционированный доступ.
  4. **Удобство обслуживания**. Хранимые процедуры можно изменять, не затрагивая использующие их приложения.
       Это облегчает внесение изменений в схему базы данных или логику запросов без разрушения существующих приложений.
  5. **Согласованность**. Хранимые процедуры позволяют обеспечивать согласованность операций с базой данных,
       инкапсулируя сложную логику и применяя бизнес-правила. Это помогает предотвратить возникновение различных ошибок.
     
### 54. Что такое функция и чем она отличается от хранимой процедуры?
    
  Функция SQL – это заранее определенный фрагмент кода, который выполняет конкретную задачу, например,  
  возвращает значение или манипулирует данными.  
  Функции могут принимать входные параметры, выполнять вычисления и  возвращать значения, основанные на  
  входных параметрах и других факторах.  
    
  Отличия функций от процедур
    
  1. **Возвращаемое значение**. Функции всегда возвращают значение, в то время как хранимые процедуры могут этого не делать.  
  2. **Входные параметры**. Функции могут иметь входные параметры, но не могут иметь выходные.  
       Хранимые процедуры могут иметь как входные, так и выходные параметры.  
  3. **Выполнение**. SQL-функции выполняются как часть оператора, в то время как хранимые процедуры  
       выполняются как независимые единицы кода.  
  4. **Сложность**. Функции обычно проще и направлены на выполнение конкретных задач, в то время как хранимые  
       процедуры могут быть более сложными и включать в себя несколько операторов SQL и логику программирования.
     
### 55. Что такое кластерный индекс и чем он отличается от некластерного?
    
  Кластерный индекс – это тип индекса, который определяет порядок данных в таблице. 
  Когда создается кластерный индекс, данные в таблице сортируются на основе значения ключа в индексе.
  Эти значения используются для навигации по индексу и поиска строк в таблице.  
  То есть, данные в таблице будут храниться в отсортированном виде, только если для неё создан 
  кластерный индекс. Таблица без такого индекса называется кучей.  
    
  Некластерный индекс – это тип индекса, который создается отдельно от данных таблицы. В отличие от 
  кластерного, некластерный индекс не определяет порядок данных в таблице. Вместо этого он создает отдельную  
  структуру данных, содержащую значения ключей индекса и указатель на местоположение данных в таблице.  
  В некластерном индексе значения ключей индекса хранятся в отдельной структуре данных, отличной от 
  данных таблицы. Это позволяет более гибко подходить к созданию индексов, поскольку для одной таблицы можно  
  создать несколько некластерных индексов для различных столбцов.  
    
  1. **Физический порядок.** Кластерный индекс определяет физический порядок данных в таблице, а некластерный — нет.  
        
  2. **Сортировка.** Кластерный индекс сортирует данные в таблице на основе значения ключа, в то время как
       некластерный индекс создает отдельную структуру данных, содержащую значение ключа и указатель на местоположение данных.  
        
  3. **Ключевые столбцы.** Кластерный индекс может быть создан только для одного уникального столбца таблицы, 
       в то время как некластерный индекс может быть создан для нескольких столбцов.  
        
  4. **Страницы данных.** В кластерном индексе страницы данных физически хранятся в том же порядке, что и
      значения ключа, в то время как в некластерном индексе это не является обязательным условием.
     
### 56. Что такое триггер и как он используется?

  По сути это тип хранимой процедуры, которая выполняется автоматически в ответ на определенные события или  
  изменения в базе данных (обновление, вставка, удаление таблицы).  
  Как правило, они используются для выполнения бизнес-правил, поддержания ссылочной целостности или регистрации  
  изменений в базе данных. Триггеры создаются с помощью оператора CREATE TRIGGER, а затем определяется, будут ли  
  они выполняться до или после наступления события.  
    
### 57. Что такое ограничение SQL и какие распространенные типы вы знаете?
    
  Ограничения — это правила, которые прописываются для таблиц БД для обеспечения точности, последовательности  
  и достоверности данных.  
    
  **NOT NULL** указывает, что столбец обязательно должен содержать значение и не может оставаться незаполненным.  
    
  **UNIQUE** определяет, что столбец должен содержать уникальные  значения и не может содержать дубликаты.  
    
  **PRIMARY KEY** определяет, что столбец или набор столбцов  должны содержать уникальные значения и служить первичным  
    ключом для каждой строки таблицы.  
    
  **FOREIGN KEY** или вторичный ключ, определяет, что столбец или набор столбцов в одной таблице связан со столбцом  
    или набором столбцов в другой таблице.  
    
   **CHECK** задает условие, которое должно быть истинным для  каждой строки таблицы. Это ограничение гарантирует, что  
    данные в таблице соответствуют определенным критериям, и предотвращает ввод недопустимых данных

### 58. Можно ли в HAVING использовать алиасы?  

  Зависит от типа СУБД. В PostgreSQL нельзя, в Clickhouse можно.   

### 59. [Как решать связь многие-ко-многим?

  Через создание 3 таблицы. Bridge таблица.  
  https://www.youtube.com/watch?v=U6w7PlU97cU  

### 60. Есть две таблицы с одним столбцом. Пусть столбец называется key (ключ). В таблице "A" 10 уникальных значений.  
В таблице "B" 100 необязательно уникальных значений. Какое максимальное и минимальное кол-во строчек может получиться  
при left join'е таблицы "B" к таблице "A"?  

  Минимальное - 10. Максимальное - 109.  

  

