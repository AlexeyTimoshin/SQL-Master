Дана таблица 
| id1  | id2   |
| ---- |  ---- |
|null  |  1    |
|2     |  2    |
|5     |  null |
|null  |  null |
| 2    |  3    |

Что выведет запрос? 
1)  count(*) = 5 (*/1/'id1') - агрегат с нулевым аргументом
2)  count(1) = 5  
3)  count(id1) = 3  
4)  count('id1') = 5  
5)  count(null) = 0  # NULL != NULL
6)  count(distinct id1) = 2
7)  min(id1) = 2
8)  max(id1) = 5
9)  sum(id1) = 9
10) sum(id1+id2) = 9 - сумму по id1
11) avg(id1) = 3.0
12) sum(1) = 5  - вернет количество строк


```SQL
Чем отличаются эти 2 запроса и почему ?

1.
SELECT * FROM t2
LEFT JOIN t1 ON  t1.id = t2.id
AND t1.n IS null
 2.
SELECT * FROM t2
LEFT JOIN t1 ON  t1.id = t2.id
WHERE t1.n IS null

1
останутся все строки t1 + к строкам, у 
которых t1.n IS null приджойнятся по id строки из 2-ой таблички

2
сначала приджойнятся по всем айдишникам строки 
из 1 и 2-ой таблички (обычным лефтом)
а потом where оставит только те строки, у которых t1.n IS NULL
```

```SQL
Отличаются ли запросы: 
1 select * from table_a a 
  left outer join table_b on (a.id = b.id and b.some_column = 'X')

2 select * from table_a a 
  left outer join table_b on (a.id = b.id) where b.some_column = 'X'?

Отличия запросов:

-> в этом случае все строки с левой таблицы будут на месте, 
но по условию могут быть null из второй таблицы 

-> в этом случае отфильтруются все строки по условию и будет 
набор данных меньше, чем выше
```

```SQL
LEETCODE 1141. User Activity for the Past 30 Days I

```

```SQL
AMAZON TASKS
SELECT customer_name
FROM orders
EXCEPT
SELECT o1.customer_name
FROM orders o1
join orders o2
	ON o1.customer_name = o2.customer_name  
	AND o1.prod_name = 1 
    AND o2.prod_name = 2
```

```SQL
Как найти зарплату сотрудника, которая является n-й по величине в таблице

SELECT salary
FROM employees
ORDER BY salary DESC
LIMIT 2, 1;
```

```SQL
Как найти второе по величине значение в столбце

SELECT MAX(salary) AS second_highest_salary
FROM employees
WHERE salary < (
  SELECT MAX(salary) FROM employees
);
```

> 20 вопросов и задач по SQL на собеседовании с ответами
> [https://vc.ru/life/443626-20-voprosov-i-zadach-po-sql-na-sobesedovanii-s-otvetami](https://vc.ru/life/443626-20-voprosov-i-zadach-po-sql-na-sobesedovanii-s-otvetami)  

> 7 вопросов по SQL на собеседовании в Microsoft, Airbnb, Twitter с ответами 
> [https://vc.ru/hr/504904-7-voprosov-po-sql-na-sobesedovanii-v-microsoft-airbnb-twitter-s-otvetami](https://vc.ru/hr/504904-7-voprosov-po-sql-na-sobesedovanii-v-microsoft-airbnb-twitter-s-otvetami)  

### LEETCODE 1661
```SQL
SELECT A1.machine_id, 
       ROUND(AVG(A2.timestamp - A1.timestamp)::numeric, 3) AS processing_time
FROM Activity AS A1
JOIN Activity AS A2
ON A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id 
AND A1.activity_type = 'start' AND A2.activity_type = 'end'
GROUP BY A1.machine_id;
```

<details>
<summary> КОД ДЛЯ ТАБЛИЦЫ </summary>
	
```sql
Create table a (id int, date date, value int);
INSERT INTO a (id, date, value) VALUES
(1, '2021-01-01', NULL),
(1, '2021-01-01', 8),
(1, '2021-01-01', NULL),
(1,'2021-01-01', NULL),
(1, '2021-01-01', NULL), 
(2,'2021-01-02', 122),
(2, '2021-01-02', NULL),
(2, '2021-01-02', NULL),
(3,'2021-01-03', 32),
(3,'2021-01-03', NULL),
(4, '2021-01-04', NULL),
(4, '2021-01-04', 86),
(4, '2021-01-04', NULL);
```
</details>

### Fucing Yandex question Дана таблица - надо получить такую. Go, bitch.

id|time|value|
---|---|---|
|1| 2021-01-01| NULL|
|1| 2021-01-01| 8|
|1| 2021-01-01| NULL|
|1|2021-01-01| NULL|
|1|2021-01-01| NULL| 
|2|2021-01-02| 122|
|2| 2021-01-02| NULL|
|2| 2021-01-02| NULL|
|3|2021-01-03| 32|
|3|2021-01-03| NULL|
|4| 2021-01-04| NULL|
|4| 2021-01-04| 86|
|4| 2021-01-04| NULL|

id|time|value|
---|---|---|
|1| 2021-01-01| NULL|
|1| 2021-01-01| 8|
|1| 2021-01-01| 8|
|1|2021-01-01| 8|
|1|2021-01-01| 8| 
|2|2021-01-02| 122|
|2| 2021-01-02| 122|
|2| 2021-01-02| 122|
|3|2021-01-03| 32|
|3|2021-01-03| 32|
|4| 2021-01-04| NULL|
|4| 2021-01-04| 86|
|4| 2021-01-04| 86|


```sql
WITH cte as
(SELECT  id, date, VALUE, 
	 ROW_NUMBER() OVER(PARTITON BY ID) AS rw_num
from a)

SELECT  id, 
	date, 
	CASE 
        WHEN rw_num = 1 AND VALUE IS NULL THEN NULL 
        ELSE MAX(value) OVER(PARTITION BY id ORDER BY date)       
        END AS val
FROM cte 
```

### Расчёт медианы 

```sql
-- Мой "выстраданный" вариант
WITH ct as (
SELECT price, 
	ROW_NUMBER() OVER(ORDER BY price) rw,
 	PERCENT_RANK() OVER(ORDER BY price) pr
FROM t
)
SELECT   CASE 
	 WHEN MAX(rw) % 2 = 0 THEN AVG(price) FILTER (WHERE rw IN (SELECT MAX(rw) / 2 FROM ct UNION SELECT MAX(rw) / 2 + 1 FROM ct))
         WHEN MAX(rw) % 2 = 1 THEN MAX(price) FILTER (WHERE rw IN (SELECT MAX(rw) / 2  + 1  FROM ct))
         END as med
FROM ct


-- Karpov courses - И это неправильное решение ммммм нужно проверять.

WITH main_table AS
( SELECT order_price,
	ROW_NUMBER() OVER (ORDER BY order_price) AS row_number,
	COUNT(*) OVER() AS total_rows
FROM
	( SELECT SUM(price) AS order_price
	FROM
	( SELECT order_id,
		product_ids,
		UNNEST(product_ids) AS product_id
	  FROM orders
	  WHERE order_id NOT IN
			(SELECT order_id
			FROM user_actions
			WHERE action='cancel_order')
		) t3
	LEFT JOIN products USING(product_id)
	GROUP BY order_id ) t1 )

SELECT AVG(order_price) AS median_price
FROM main_table
WHERE row_number BETWEEN total_rows/2.0 AND total_rows/2.0 + 1 
```
