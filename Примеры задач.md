Дана таблица 
| id1  | id2   |
| ---- |  ---- |
|null  |  1    |
|2     |  2    |
|5     |  null |
|null  |  null |
| 2    |  3    |

Что выведет запрос? 
1)  count(*) = 5 (*/1/'id1') - агрегат с нулевым аргументом
2)  count(1) = 5  
3)  count(id1) = 3  
4)  count('id1') = 5  
5)  count(null) = 0  # NULL != NULL
6)  count(distinct id1) = 2
7)  min(id1) = 2
8)  max(id1) = 5
9)  sum(id1) = 9
10) sum(id1+id2) = 9 - сумму по id1
11) avg(id1) = 3.0
12) sum(1) = 5  - вернет количество строк


```SQL
Чем отличаются эти 2 запроса и почему ?

1.
SELECT * FROM t2
LEFT JOIN t1 ON  t1.id = t2.id
AND t1.n IS null
 2.
SELECT * FROM t2
LEFT JOIN t1 ON  t1.id = t2.id
WHERE t1.n IS null

1
останутся все строки t1 + к строкам, у 
которых t1.n IS null приджойнятся по id строки из 2-ой таблички

2
сначала приджойнятся по всем айдишникам строки 
из 1 и 2-ой таблички (обычным лефтом)
а потом where оставит только те строки, у которых t1.n IS NULL
```

```SQL
Отличаются ли запросы: 
1 select * from table_a a 
  left outer join table_b on (a.id = b.id and b.some_column = 'X')

2 select * from table_a a 
  left outer join table_b on (a.id = b.id) where b.some_column = 'X'?

Отличия запросов:

-> в этом случае все строки с левой таблицы будут на месте, 
но по условию могут быть null из второй таблицы 

-> в этом случае отфильтруются все строки по условию и будет 
набор данных меньше, чем выше
```

```SQL
LEETCODE 1141. User Activity for the Past 30 Days I

```

```SQL
AMAZON TASKS
SELECT customer_name
FROM orders
EXCEPT
SELECT o1.customer_name
FROM orders o1
join orders o2
	ON o1.customer_name = o2.customer_name  
	AND o1.prod_name = 1 
    AND o2.prod_name = 2
```

```SQL
Как найти зарплату сотрудника, которая является n-й по величине в таблице

SELECT salary
FROM employees
ORDER BY salary DESC
LIMIT 2, 1;
```

```SQL
Как найти второе по величине значение в столбце

SELECT MAX(salary) AS second_highest_salary
FROM employees
WHERE salary < (
  SELECT MAX(salary) FROM employees
);
```

> 20 вопросов и задач по SQL на собеседовании с ответами
> [https://vc.ru/life/443626-20-voprosov-i-zadach-po-sql-na-sobesedovanii-s-otvetami](https://vc.ru/life/443626-20-voprosov-i-zadach-po-sql-na-sobesedovanii-s-otvetami)  

> 7 вопросов по SQL на собеседовании в Microsoft, Airbnb, Twitter с ответами 
> [https://vc.ru/hr/504904-7-voprosov-po-sql-na-sobesedovanii-v-microsoft-airbnb-twitter-s-otvetami](https://vc.ru/hr/504904-7-voprosov-po-sql-na-sobesedovanii-v-microsoft-airbnb-twitter-s-otvetami)  

### LEETCODE 1661
```SQL
SELECT A1.machine_id, 
       ROUND(AVG(A2.timestamp - A1.timestamp)::numeric, 3) AS processing_time
FROM Activity AS A1
JOIN Activity AS A2
ON A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id 
AND A1.activity_type = 'start' AND A2.activity_type = 'end'
GROUP BY A1.machine_id;
```

<details>
<summary> КОД ДЛЯ ТАБЛИЦЫ </summary>
	
```sql
Create table a (id int, date date, value int);
INSERT INTO a (id, date, value) VALUES
(1, '2021-01-01', NULL),
(1, '2021-01-01', 8),
(1, '2021-01-01', NULL),
(1,'2021-01-01', NULL),
(1, '2021-01-01', NULL), 
(2,'2021-01-02', 122),
(2, '2021-01-02', NULL),
(2, '2021-01-02', NULL),
(3,'2021-01-03', 32),
(3,'2021-01-03', NULL),
(4, '2021-01-04', NULL),
(4, '2021-01-04', 86),
(4, '2021-01-04', NULL);
```
</details>

### Fucing Yandex question Дана таблица - надо получить такую. Go, bitch.

id|time|value|
---|---|---|
|1| 2021-01-01| NULL|
|1| 2021-01-01| 8|
|1| 2021-01-01| NULL|
|1|2021-01-01| NULL|
|1|2021-01-01| NULL| 
|2|2021-01-02| 122|
|2| 2021-01-02| NULL|
|2| 2021-01-02| NULL|
|3|2021-01-03| 32|
|3|2021-01-03| NULL|
|4| 2021-01-04| NULL|
|4| 2021-01-04| 86|
|4| 2021-01-04| NULL|

id|time|value|
---|---|---|
|1| 2021-01-01| NULL|
|1| 2021-01-01| 8|
|1| 2021-01-01| 8|
|1|2021-01-01| 8|
|1|2021-01-01| 8| 
|2|2021-01-02| 122|
|2| 2021-01-02| 122|
|2| 2021-01-02| 122|
|3|2021-01-03| 32|
|3|2021-01-03| 32|
|4| 2021-01-04| NULL|
|4| 2021-01-04| 86|
|4| 2021-01-04| 86|


```sql
WITH cte as
(SELECT  id, date, VALUE, 
	 ROW_NUMBER() OVER(PARTITON BY ID) AS rw_num
from a)

SELECT  id, 
	date, 
	CASE 
        WHEN rw_num = 1 AND VALUE IS NULL THEN NULL 
        ELSE MAX(value) OVER(PARTITION BY id ORDER BY date)       
        END AS val
FROM cte 
```

### Расчёт медианы 

```sql
-- Мой "выстраданный" вариант
WITH ct as (
SELECT price, 
	ROW_NUMBER() OVER(ORDER BY price) rw,
 	PERCENT_RANK() OVER(ORDER BY price) pr
FROM t
)
SELECT   CASE 
	 WHEN MAX(rw) % 2 = 0 THEN AVG(price) FILTER (WHERE rw IN (SELECT MAX(rw) / 2 FROM ct UNION SELECT MAX(rw) / 2 + 1 FROM ct))
         WHEN MAX(rw) % 2 = 1 THEN MAX(price) FILTER (WHERE rw IN (SELECT MAX(rw) / 2  + 1  FROM ct))
         END as med
FROM ct


-- Karpov courses - И это неправильное решение ммммм нужно проверять.

WITH main_table AS
( SELECT order_price,
	ROW_NUMBER() OVER (ORDER BY order_price) AS row_number,
	COUNT(*) OVER() AS total_rows
FROM
	( SELECT SUM(price) AS order_price
	FROM
	( SELECT order_id,
		product_ids,
		UNNEST(product_ids) AS product_id
	  FROM orders
	  WHERE order_id NOT IN
			(SELECT order_id
			FROM user_actions
			WHERE action='cancel_order')
		) t3
	LEFT JOIN products USING(product_id)
	GROUP BY order_id ) t1 )


SELECT AVG(order_price) AS median_price
FROM main_table
WHERE row_number BETWEEN total_rows/2.0 AND total_rows/2.0 + 1 
```

### Задача на 350к. Найдите количество двоек у тех учеников, у которых количество пятерок не менее 3.
<details> <summary> Код для таблицы </summary>
CREate table mark (name VARCHAR, mark int);
INSERT into mark (name, mark) VALUES 
('Jonh', 5),
('Jonh', 5),
('Jonh', 5), 
('Jonh', 2),
('Jonh', 2),
('Julia', 5),
('Julia', 5), 
('Julia', 5), 
('Julia', 2),
('Jon Snow', 5),
('Jon Snow', 5),
('Jon Snow', 5);
</details>

name | mark|
---|---|
Jonh| 5|
Jonh| 5|
Jonh| 5| 
Jonh| 2|
Jonh| 2|
Julia| 5|
Julia| 5| 
Julia| 5| 
Julia| 2|
Jon Snow| 5|
Jon Snow| 5|
Jon Snow| 5|
```sql
SELECT name, COUNT(*)
FROM mark 
WHERE name IN (select name from mark WHERE mark = 5 GROUP BY name HAVING COUNT(*) = 3) and mark = 2
GROUP BY name

SELECT name, mark_2
FROM 
(
  SELECT name, 
		 COUNT(mark) FILTER (WHERE mark = 5) as count_5, 
         COUNT(mark) FILTER (WHERE mark = 2) mark_2
FROM mark 
GROUP BY name ) t1
WHERE count_5 >= 3

SELECT name, COUNT(*) FILTER (WHERE mark = 2)
FROM mark 
WHERE EXISTS (select name from mark WHERE mark = 5 GROUP BY name HAVING COUNT(*) = 3)
GROUP BY name 

```

### Задача на мидла биайщика -- древовидная структура таблицы - "ммм, хуета".
Есть три таблицы:
• «Товары» (хранит информацию о товарах). Структура:  
Код int  
Название nvarchar(100)  
Актуальность bit  (Принимает значения 1, 0, NULL)
 
• «Группы» (хранит информацию о товарных группах). Каталог товаров, состоящий из групп,  
имеет древовидную структуру. Поле ВходитВ указывает на Код группы, в которую он входит.  
У групп верхнего уровня поле ВходитВ=0. Структура:  
Код int  
Название nvarchar(50)  
ВходитВ int  
 
• «Группы_Товары» (хранит информацию о нахождении товара в товарной группе).  
Товар может находится в группе любого уровня вложенности. Структура:  
КодГруппы int (FK Группы.Код)  
КодТовара int (FK Товары.Код)  
 
Задача: необходимо написать SQL запрос, который вернет список актуальных товаров и  
групп верхнего уровня, в которые эти товары так или иначе входят.  

<details> <summary> Code for tables </summary>
-- судя по типам данных это MS SQL
CREATE TABLE products(code int, name varchar, relevance int); 
CREATE TABLE groups(code int, name varchar, include_id int);
CREATE TABLE group_products(code_group int, code_product int);

INSERT INTO products (code, name, relevance) VALUES
(1, 'spagetti', 1),
(2, 'fuzzilli', 1),
(3, 'bavette', 0),
(4, 'ketchup', 1),
(5, 'tabasco', 0),
(6,  'soya', 1);

INSERT INTO groups(code, name, include_in) VALUES -- тут нихуя непонятно что и как куда входит
()

</details>

Products  
code | Name |  relevance|
---|---|---|
1| spagetti| 1|
2| fuzzilli| 1|
3| bavette | 0|
4| ketchup | 1|
5| tabasco | 0|
6|  soya   | 1|

Group
code|name|include_in|
---|---|---|
0| pastas| 0|
1| pastas| |
1| pastas| 2|
2| souces| 0|
2| souces| 1|

 «Группы» (хранит информацию о товарных группах). Каталог товаров, состоящий из групп,  
имеет древовидную структуру. Поле ВходитВ указывает на Код группы, в которую он входит.  
У групп верхнего уровня поле ВходитВ=0. 

Group_products
code_group| code_products|
---|---|
0|1|
1|2|
2|3|
0|4|
1|5|
1|6|
